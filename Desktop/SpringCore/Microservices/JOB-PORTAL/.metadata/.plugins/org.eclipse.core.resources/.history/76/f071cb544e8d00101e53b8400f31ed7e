package com.ey.service;
 
import com.ey.dto.*;
import com.ey.entity.*;
import com.ey.exception.*;
import com.ey.repository.*;
import java.util.List;
import java.util.stream.Collectors;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
 
@Service
public class ApplicationServiceImpl implements ApplicationService {
 
    private final ApplicationRepository appRepo;
    private final JobRepository jobRepo;
    private final UserRepository userRepo;
 
    public ApplicationServiceImpl(ApplicationRepository appRepo, JobRepository jobRepo, UserRepository userRepo) {
        this.appRepo = appRepo;
        this.jobRepo = jobRepo;
        this.userRepo = userRepo;
    }
 
    @Override
    @Transactional
    public ApplicationResponse applyToJob(Long jobId) {
        String email = (String) SecurityContextHolder.getContext().getAuthentication().getName();
        User seeker = userRepo.findByEmail(email).orElseThrow(() -> new NotFoundException("User not found"));
        Job job = jobRepo.findById(jobId).orElseThrow(() -> new NotFoundException("Job not found"));
 
        if (appRepo.existsByJobIdAndSeekerId(jobId, seeker.getId())) {
            throw new ConflictException("Already applied to this job");
        }
 
        Application app = new Application();
        app.setJob(job);
        app.setSeeker(seeker);
        Application saved = appRepo.save(app);
 
        ApplicationResponse resp = new ApplicationResponse();
        resp.setId(saved.getId());
        resp.setJobTitle(job.getTitle());
        resp.setSeekerName(seeker.getName());
        resp.setStatus(saved.getStatus().name());
        resp.setAppliedAt(saved.getAppliedAt());
        return resp;
    }
 
    @Override
    public List<ApplicationResponse> getMyApplications() {
        String email = (String) SecurityContextHolder.getContext().getAuthentication().getName();
        User seeker = userRepo.findByEmail(email).orElseThrow(() -> new NotFoundException("User not found"));
        return appRepo.findBySeekerId(seeker.getId()).stream().map(this::toDto).collect(Collectors.toList());
    }
 
    @Override
    public List<ApplicationResponse> getApplicationsForJob(Long jobId) {
        Job job = jobRepo.findById(jobId).orElseThrow(() -> new NotFoundException("Job not found"));
        return appRepo.findByJobId(jobId).stream().map(this::toDto).collect(Collectors.toList());
    }
 
    @Override
    @Transactional
    public ApplicationResponse updateStatus(Long applicationId, UpdateStatusRequest request) {
        Application app = appRepo.findById(applicationId).orElseThrow(() -> new NotFoundException("Application not found"));
        // ownership: check HR owns the job
        String email = (String) SecurityContextHolder.getContext().getAuthentication().getName();
        User current = userRepo.findByEmail(email).orElseThrow(() -> new NotFoundException("User not found"));
        if (current.getRole() != Role.HR) throw new ForbiddenException("Only HR can update application status");
        if (!app.getJob().getHr().getId().equals(current.getId())) throw new ForbiddenException("Not owner of this job");
 
        app.setStatus(ApplicationStatus.valueOf(request.getStatus()));
        Application saved = appRepo.save(app);
        return toDto(saved);
    }
 
    private ApplicationResponse toDto(Application a) {
        ApplicationResponse r = new ApplicationResponse();
        r.setId(a.getId());
        r.setJobTitle(a.getJob().getTitle());
        r.setSeekerName(a.getSeeker().getName());
        r.setStatus(a.getStatus().name());
        r.setAppliedAt(a.getAppliedAt());
        return r;
    }
}